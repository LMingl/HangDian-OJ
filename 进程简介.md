### 一：进程
#### 进程号(PID)
每个进程都由一个进程号来标识，其类型为pid_t，进程号的范围为0-32767
进程号总是唯一的，但进程号可以重用。
Linux系统的进程号由0开始。进程号为0及1的进程由内核创建
进程号为0的进程通常是调度进程，常被称为交换进程。进程号为1的进程通常是init进程

**进程号（PID）**
**父进程号（PPID）**
**进程组号（PGID）**
进程组是一个或多个进程的集合。他们相互关联，进程组可以接受同一终端的各种信号

包含的头文件：
 `#include<sys/type.h>`
 `#include<unistd.h>`
`pid_t getpid(void)  pid_t getppid(void) pid_t getpgid(pid_t pid)`

#### 进程的创建
 `#include<sys/type.h>`
 `#include<unistd.h>`

`pid_t fork(void)`: 从一个已存在的进程中创建一个新进程，新进程为子进程, 原进程为父进程
**返回值**：
成功：子进程中返回0， 父进程中返回子进程的PID
失败：返回-1
使用fork函数得到的子进程是父进程的一个复制品，**它从父进程继承了整个进程的地址空间**比如局部、全局变量、缓冲区等，使用fork函数的代价是很大的
子进程从fork（）开始执行

`pid_t vfork(void)`
功能：
在已有的进程中创建子进程
vfork()保证子进程先运行，在它调用exec或exit之后，父进程才可能调度运行
vfork()但它并不将父进程的地址空间完全复制到子进程中，因为调用exec或exit,于是也就不访问该地址空间,**在子进程调用exec或exit之前，它在父进程的地址空间中运行。**会共用地址空间
返回值：
创建子进程成功，则在子进程中返回0，父进程返回子进程的ID，出错返回-1
note:
不能用return 返回

标准IO提供了三种类型的缓冲：
全缓冲（大小不定）：在填满标准IO缓冲区后，才进行实际的IO操作。
行缓冲（大小不定）：在遇到换行符时，标准IO库执行IO操作。允许我们一次输入一个字符，但只有写了一行后才进行实际的IO缓冲。
不带缓冲

#### 进程的挂起
进程在一定时间内没有动作称为进程的挂起
 `#include<unistd.h>`
`unsight int sleep(unsigned int sec)`
function:
进程挂起指定秒数，直到指定的时间用完或收到信号才解除挂起
return:
若挂起到指定秒数则返回0，若有信号中断则返回剩余秒数
注意：
到时后并不会立即执行，系统只是将该进程切换到就绪态

#### 进程的等待
父子进程有时需要简单的进程间同步，如父进程等待子进程结束
 `#incldue<sys/types.h>`
 `#include<sys/wait.h>`
函数：wait()、waitpid()

`pid_t wait(int *status)`
功能：
等待子进程的终止，如果子进程终止了，此函数会会回收子进程的资源。
调用wait()函数的进程会挂起，直到它的一个子进程退出或收到一个不能被忽视的信号时才被唤醒
参数：
函数返回时，参数status中包含子进程退出时的状态信息。子进程的退出信息在一个int中包含了多个字段，用宏可以取出其中的每个字段

`pid_t waitpid(pid_t pid, int *status, int options)`
功能：等待子进程终止，如果子进程终止了，此函数会回收子进程的资源
参数pid的类型：
pid > 0
pid = 0
pid = -1
pid < -1
参数option:
0:

**特殊进程：**
僵尸进程：
孤儿进程：
守护进程：特殊的孤儿进程

#### 进程的终止exit
continue
break
return
exit     在进程的子函数中调用，进程被杀死

linux下通过以下函数结束进程
 #include<stdio.h>
 void exit(int value)  ->库函数
 参数：返回给父进程的参数

 #include<unistd.h>
void _exit(int value)  ->系统调用

#### 注册进程退出清理
 #include<stdlib.h>
 int atexit(void (*function)(void))
 功能：注册进程正常结束前调用的函数，进程退出执行注册函数
 正常结束前调用函数的顺序和注册时的顺序相反

#### 进程的替换
exec函数族，是由六个exec函数组成(execute a file)
 1.exec函数族提供了六种在进程中启动另一个程序的方法
 2.exec函数族可以根据指定的文件名或目录名找到可执行文件
 3.调用exec函数的进程并不创建新的进程，故调用前后，进程的进程号并不会改变，全由新程序替换，而新程序则从main函数开始执行
 **exec函数族取代调用进程的数据段、代码段、堆栈段**

**exec函数族**
 #include<unistd.h>
int execl(const char *pathname,const char *arg()   , NULL)
int execlp(const char *file, const char *arg,   , NULL)
int execle(const char *path, const char *arg,    , char * const envp[])
int execv(const char *path, char *const argv[])
int execvp()
int execvpe()

一个进程调用exec后，除了进程ID，进程还保留以下特征不变：
父进程号
进程组号
控制终端
根目录
当前工作目录
进程信号屏蔽集
未处理信号

int system(const char *command)

### 二: 进程间通信
进程间通信(IPC：inter processes communication)
进程是一个独立的资源分配单元，不同进程(用户进程)之间的资源是独立的，不能在一个进程访问另一个进程的资源
进程不是孤立的，不同进程需要进行信息的交互和状态的传递等，因此需要进程间的通信

#### 进程间通信功能
**数据传输**:一个进程需要将它的进程发送给另一个进程
**资源共享**:多个进程之间共享同样的资源
**通知事件**：一个进程需要向另一个进程发送消息，通知它们发生了某种事件
**进程控制**：有些进程希望完全控制另一个进程的执行

POSIX进程间通信
Socket进程间通信
#### linux支持的主要进程通信的通信机制
![](pictures/进程间通信.png)

#### 三：信号
信号是软件中断，它是在软件层次上对中断机制的一种模拟
信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断，转而处理某一个突发事件
**信号是一种异步通信方式**
信号可以直接进行用户空间进程和内核空间进程的交互，内核空间可以利用它来通知用户进程发生了哪些系统事件

每个信号的名字都以字符SIG开头。
每个信号和一个数字编码相对应，在头文件signum.h中
kill -l 查看信号和数字编码

以下条件产生一个信号：
1.用户按某些终端时产生信号：
Ctrl+c 产生中断信号SIGINT   Ctrl+\产生中断信号SIGQUIT ctrl + Z
2.硬件异常 
3.软件异常
4.调用kill函数将发送信号

**一个进程收到一个信号的时候，可以用如下方法进行处理**
1.执行系统的默认动作
2.忽略此信号
3.执行自定义信号处理函数 ：**函数可以采用signal函数改变信号的处理方式**
注意：SIGKILL 和 SIGSTOP 不能更改信号的处理方式，因为他们提供了一种使进程终止的可靠方法

 #include<signal.h>
sighandler_t signal(int signum, sighandler_t handler)
功能：
注册信号处理函数
参数：
handler的取值：
    忽略该信号：SIG_IGN
    执行系统默认动作：SIG_DFL
    自定义信号处理函数：信号处理函数名

signal函数的返回值：




#### 信号的基本操作
kill函数：
 #include<signal.h>
 int kill(pid_t pid, int signum)
功能：
给指定进程发信号

**pid取值有四种情况：**
pid > 0:给进程ID为pid的进程发信号
pid = 0：当前进程所在的进程组中的所有进程
pid = -1：系统内的所有进程
pid < -1 : 将信号传送给指定进程组的所有进程，进程组号为pid的绝对值

alarm函数：
 #include<unistd.h>
unsigned int alarm(unsigned int seconds)

raise函数：
 #include<signal.h>
int raise(int signum);
功能：给调用进程本身送一个信号(立刻干掉)

abort()函数
 #include<stdlib.h>
 void abort(void)
 功能：向进程发送一个SIGABRT信号，默认情况下进程会退出

pause函数：

#### 可重入函数
可重入函数是指函数可以由多个任务并发执行，而不必担心数据错误
编写可重入的函数：
   1.不使用静态的数据、全局变量（除非用信号量互斥）
   2.不调用动态内存分配、释放的函数
   3.不调用任何不可重入的函数（如：标准IO）
注意：
即使信号处理函数使用的都是可重入函数，也要注意进入处理函数时，首先保存errno的值


#### 信号集
#### 信号集概述
为了方便对多个信号进行处理，在Linux系统引入了信号集，信号集是用来表示多个信号的数据类型

#### 信号集数据类型
 sigset_t
    
    # define _SIGSET_NWORDS (1024 / (8 * sizeof (unsigned long int)))
    typedef struct
    {
      unsigned long int __val[_SIGSET_NWORDS];
    } __sigset_t;

#### 信号集相关操作函数
 #include<signal.h>
`sigemptyset()
sigfillset()
sigismember()
sigaddset()
sigdelset()`

#### 信号阻塞集（屏蔽集）
每个进程都有一个阻塞集，它用来描述哪些信号递送到该进程的时候被阻塞（在信号发生时记住它，直到进程准备好时再将信号通知进程）
是暂缓信号的传递

sigprocmask函数
创建一个阻塞集合
 #include<signal.h>
int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);


### 四：管道、命名管道
#### 管道概述
管道（pipe）又称无名管道
无名管道是一种特殊类型的文件，在应用层体现为**两个**打开的文件描述符
























